// Generated by CoffeeScript 2.0.0-beta8
void function () {
  BitmapFont = function () {
    function BitmapFont(param$) {
      this.image = param$;
      this.width = this.image.width / 16;
      this.height = this.image.height / 16;
    }
    BitmapFont.prototype.textWidth = function (text) {
      return text.length * this.width;
    };
    BitmapFont.prototype.drawCharCode = function (context, code, x, y) {
      var sx, sy;
      sx = this.width * (code & 15);
      sy = this.height * (code >> 4);
      context.drawImage(this.image, sx, sy, this.width, this.height, x, y, this.width, this.height);
    };
    BitmapFont.prototype.drawText = function (context, text, x, y) {
      var i;
      for (var cache$ = function () {
            var accum$;
            accum$ = [];
            for (var i$ = 0; 0 <= text.length ? i$ < text.length : i$ > text.length; 0 <= text.length ? ++i$ : --i$)
              accum$.push(i$);
            return accum$;
          }.apply(this, arguments), i$ = 0, length$ = cache$.length; i$ < length$; ++i$) {
        i = cache$[i$];
        this.drawCharCode(context, text.charCodeAt(i), x, y);
        x += this.width;
      }
    };
    BitmapFont.prototype.textToImage = function (text) {
      var canvas, context;
      canvas = document.createElement('canvas');
      canvas.width = this.textWidth(text);
      canvas.height = this.height;
      context = canvas.getContext('2d');
      this.drawText(context, text, 0, 0);
      return canvas;
    };
    return BitmapFont;
  }();
  TexturePacker = function () {
    Node = function () {
      function Node(param$, param$1, param$2, param$3) {
        this.left = param$;
        this.top = param$1;
        this.width = param$2;
        this.height = param$3;
      }
      Node.prototype.add = function (image) {
        var cache$, cache$1, dh, dw, height, width;
        cache$ = image;
        width = cache$.width;
        height = cache$.height;
        if (null != this.image) {
          return null;
        } else if (null != this.a && null != this.b) {
          cache$1 = this.a.add(image);
          if (null != cache$1)
            return cache$1;
          else
            return this.b.add(image);
        } else if (width === this.width && height === this.height) {
          this.image = image;
          return this;
        } else if (width <= this.width && height <= this.height) {
          dw = this.width - width;
          dh = this.height - height;
          if (dw > dh) {
            this.a = new Node(this.left, this.top, width, this.height);
            this.b = new Node(this.left + width, this.top, dw, this.height);
          } else {
            this.a = new Node(this.left, this.top, this.width, height);
            this.b = new Node(this.left, this.top + height, this.width, dh);
          }
          return this.a.add(image);
        } else {
          return null;
        }
      };
      Node.prototype.each = function (func) {
        if (null != this.image) {
          func(this.image, this.left, this.top, this.width, this.height);
        } else if (null != this.a && null != this.b) {
          this.a.each(func);
          this.b.each(func);
        }
      };
      Node.prototype.draw = function (context) {
        if (null != this.image) {
          context.clearRect(this.left, this.top, this.width, this.height);
          context.drawImage(this.image, this.left, this.top);
        } else if (null != this.a && null != this.b) {
          this.a.draw(context);
          this.b.draw(context);
        }
      };
      return Node;
    }();
    function TexturePacker(param$) {
      this.textureSize = param$;
      this.root = new Node(0, 0, this.textureSize, this.textureSize);
      this.textureList = [];
      this.texture = document.createElement('canvas');
      this.texture.width = this.textureSize;
      this.texture.height = this.textureSize;
      this.context = this.texture.getContext('2d');
    }
    TexturePacker.prototype.add = function (image) {
      var node;
      node = this.root.add(image);
      if (null != node) {
        this.textureList.push(image);
        node.draw(this.context);
        return new Sprite(node.left, node.top, node.width, node.height);
      } else {
        throw new Error('failed to allocate texture space');
      }
    };
    TexturePacker.prototype.each = function (func) {
      return this.root.each(func);
    };
    return TexturePacker;
  }();
  Sprite = function () {
    function Sprite(u, v, w, h) {
      this.pos = {
        x: 0,
        y: 0
      };
      this.size = {
        x: w,
        y: h
      };
      this.uv = {
        x: u,
        y: v
      };
      this.priority = 1;
    }
    Sprite.prototype.move = function (x, y) {
      this.pos.x = x;
      this.pos.y = y;
      return this;
    };
    Sprite.prototype.setPriority = function (param$) {
      this.priority = param$;
      return this;
    };
    Sprite.prototype.test = function (x, y) {
      return x >= this.x && x < this.x + this.width && y >= this.y && y < this.y + this.height;
    };
    return Sprite;
  }();
  DisplayList = function () {
    function DisplayList(param$, virtualWidth, virtualHeight, textureSize, overlay) {
      var displayList, glsl, instance$;
      instance$ = this;
      this.__update = function (c, d) {
        return DisplayList.prototype.__update.apply(instance$, arguments);
      };
      this.canvas = param$;
      this.texturePacker = new TexturePacker(textureSize);
      this.sprites = [];
      displayList = this;
      glsl = Glsl({
        canvas: this.canvas,
        fragment: this.shaderSource,
        variables: {
          time: 0,
          atlas: this.texturePacker.texture,
          atlasAspect: {
            x: textureSize,
            y: textureSize
          },
          displayAspect: {
            x: virtualWidth,
            y: virtualHeight
          },
          overlay: overlay,
          sprites: this.sprites,
          spritesLength: this.sprites.length
        },
        init: function () {
          return displayList.glsl = this;
        },
        update: this.__update
      });
    }
    DisplayList.prototype.createSprite = function (image, add) {
      var sprite;
      if (null == add)
        add = true;
      sprite = this.texturePacker.add(image);
      this.atlasNeedsUpdate = true;
      return sprite;
    };
    DisplayList.prototype.add = function (sprite) {
      if (this.sprites.indexOf(sprite) === -1) {
        this.sprites.push(sprite);
        this.sprites.sort(function (a, b) {
          return b.priority - a.priority;
        });
      }
      return this;
    };
    DisplayList.prototype.remove = function (sprite) {
      var i;
      if ((i = this.sprites.indexOf(sprite)) !== -1)
        this.sprites.splice(i, 1);
      return this;
    };
    DisplayList.prototype.clear = function () {
      return this.sprites.splice(0);
    };
    DisplayList.prototype.start = function () {
      return this.glsl.start();
    };
    DisplayList.prototype.stop = function () {
      return this.glsl.stop();
    };
    DisplayList.prototype.__update = function (time, dt) {
      var atlasNeedsUpdate, atlasSize;
      if (this.atlasNeedsUpdate) {
        atlasSize = this.texturePacker.textureSize;
        this.glsl.sync('atlas');
        this.glsl.set('atlasAspect', {
          x: atlasSize,
          y: atlasSize
        });
        atlasNeedsUpdate = false;
      }
      this.glsl.sync('sprites');
      this.glsl.set('spritesLength', this.sprites.length);
      this.glsl.set('time', time);
      return TWEEN.update(time);
    };
    return DisplayList;
  }();
  window.gfx = {
    BitmapFont: BitmapFont,
    DisplayList: DisplayList,
    Sprite: Sprite,
    TexturePacker: TexturePacker
  };
}.call(this);

//# sourceMappingURL=gfx.map
